**Note**
- 일단 알고리즘의 분야가 매우 다양하고, 알아야할 지식들이 너무 많다.
- 기본적으로 [분류](https://www.acmicpc.net/problem/tags)도 많아서, 기본이 되는 것들만 정리

### Basic Code
1. Heapify : up, down 방식 모두 암기 / 삭제 / 삭제
2. Quick Sort 
3. Queue / LinkedList / vector 구현
4. Permutaion / Combination 
5. Powerset
6. Binaray Search / Lower_bound / Upper_bound
7. DFS / BFS 구현
8. DisjoinSet / Kruskal / Dijkstra / Floyd Wrashall
9. Suffix Array, LCP
10. Topolgy Sort : BFS 로 구현 진입차수가 0 인 노드들을 Queue 에 넣음
11. Network Flow : BFS 로 구현
12. 이분 매칭 : DFS 로 구현
13. Line Sweeping
14. [Segment Tree](https://www.acmicpc.net/blog/view/9) : 구간 합 - 배열크기 1<<(N+1),또는 4* 속도 : O(logN)
15. BIT(Binary Index Tree, [Fenwick Tree](https://www.acmicpc.net/blog/view/21)) : 구간 합 - 배열크기 N, 속도 : O(logN)
16. LIS, LCS, LCA
17. 2 arrays sliding windows
18. CCW

### Basic Approach

0. 글과 그림으로 표현한다. 특히 조건문 / 순회 방식 / 답을 바로 구하는 것이 좋은지, 반대를 구하고 전체에서 빼는 게 좋은지?
1. DFS / BFS 로 풀어 낼 수 있는지 확인힌다.
     - 이때, 순회를 어떻게 할 것인가를 결정 ( 순열이나, 조합이냐, 부분 집합 이냐 ), 조건은 어떻게 어디서 판단할 것인가.
        - 재귀함수에 대한 이해가 필수 ([문제](https://www.acmicpc.net/problem/14888))
     - DFS : 한쪽으로 뻣어나가면서 검색하면서, 전체를 순회하고 답의 크기를 비교.
     - 2차원 그래프를 순회할때는 좌표단위로 움직일것인가? 단순히 Node 와 Node 를 연결해서 움직일 것인가 ?
     - 전자는 2차원적 움직임 / 후자는 1차원으로 next 로 
     - 노드의 개수가 10,000 개를 넘어가면, 2중 배열을 메모리 부족으로 잡을 수 없다.
       ( 따라서, 이런경우에는 반드시 linked list 로 처리해야한다.)
     - BFS : 둥굴게 둥굴게 퍼지면서 검색 - 최단거리를 찾을 때 사용, 처음나온 것이 답이다.
       ( Queue 에 넣기전에 visit 처리해야한다. )
   
2. 메모이제이션
3. 절대 답이될수 없는 부분은 가지치기로 더이상 순회하지 않는다.
4. 2차원 상의 그래프에서 객체의 움직임 표현하고 기술 하는 방식을 구현
     - 특히 여러 객체가 움직이는 경우, 충돌에 대한처리 ( 별도의 MAP 또는 충돌만 관리하는 MAP )
5. DP 로 풀수있는가? 
     - 사실상 아는 문제가 아니면 공식을 생각하기가 어렵다.

* 문제의 출력조건을 확인하라. 단순히 거리의 합인가? 목록을 출력하기 인가? 어떠한 제약조건이 있는가?
* 입력되는 노드가 크기가 백만이 넘어간다면 DP 또는 이분탐색을 고려해봐라.
* 순서가 중요하지 않다면 list 나 vector 를 사용하지 않고, 단순 배열 로 처리하기 위한 방법을 고려하라.
    - insert : szie++ 마지막 에 원소 삽입
    - delete : MAX 크기의 배열을 잡고, 마지막 원소를 삭제하려는 원소에 복사하고, size-- 를 수행.

### 유명한 알고리즘

0. 크루스컬 알고리즘 : 최소의 비용으로 각 노드를 연결한다. **연결선이 각 노드사이의 최단거리** 는 아니다.
   - Union Find 암기
   - 정렬

1. 플로이드 와샬 : 전체 노드의 최단 거리 찾기.
   - 루프 순서에 주의해 주자! 경유지 / 시작점 / 끝점 순으로 돌린다. k -> i -> j
   ```c
    for k , for i, for j
    if(adj[j][k] > adj[j][i] + adj[i][k])
       adj[j][k] = adj[j][i] + adj[i][k];
   ```
   - O(n^3) 즉, n 이 1000 이하에서만 가능하다. 그 이상이면 사용 불가.

2. 다익스트라 : 시작점에서 마지막점이 주어진 경우 최단거리 찾기 
   - prioirty queue 구현
   - 정점이 index 가 아니라, x, y 좌표로 주어지는 문제도 있다.
   - 정점과 간선의 개수가 늘아나면,..?
   - [문제](https://www.acmicpc.net/problem/1753)
   - 벨만포워드

3. Segment Tree
   - 구간 합 알고리즘
   - 원래 알고리즘은 index 에 변경값을 update 하는 것이지만, 일정 구간을 동시에 update 할 수 도 있고, 여러가지 변형이 가능하다.
   - 활용도가 생각보다 높다. 이거 풀어보자 [문제](https://www.acmicpc.net/problem/3392)
   - 변형 : Lazy propagation, PST

4. Fenwick Tree
   - 일정 범위씩 서로 다른 구간의 정보를 저장함.
   - 일정 범위 : i & -i 로 저장하고 있는 값들의 개수를 계산 (어떤 수 i를 이진수로 나타냈을 떄, 마지막 1의 위치)
   
```c
int sum(int i) {
    int ans = 0;
    while (i > 0) {
        ans += tree[i];
        i -= (i & -i);
    }
    return ans;
}
void update(int i, int num) { // num 는 diff 
    while (i <= n) {
        tree[i] += num;
        i += (i & -i);
    }
}
```

4. 라인 스위핑
   - 기본 개념은 간단하지만, 
   - 2차원으로 넘어가면, Segment Tree 나 BIT 를 이용하여, 지속적으로 update 하고 합을 계산하는 방식으로 동작한다.
   - 한쪽 방향에서 부터 한개씩 한개씩 계산하고, 누적하고, 계산하고 누적하는 방식임.
   - 따라서, 알고리즘이 너무 다양해진다.
   - 일단 그림부터 그리고, 한개씩 계산하는 방식을 글로 적어서, 데이터 누적, 계산 , 누적, 계산 이 완성이되면, 코딩
   - 데이터를 어떻게 넣고, 계산할 것인지 찾는 것이 너무 다양하다.
   - 대체로, SegmentTree 와 잘 어울린다. 
  
 
### 문자열 관련 

1. KMP : 생각보다 구현이 간단하다.
2. Suffix Array / counting sort : 생각보다 구현은 길지만, 원리는 간단하다.
3. LCP : 원리가 머리속에 잘 안들어온다. 그냥 외워라. 


### 최단거리??

최장 거리는 최단경로 알고리즘을 상황에 맞게 수정하면 된다.
( 양수를 음수로 변경해서 최단거리 구하고, 다시 음수)

**One -> N**

1.1) 간선의 가중치에 음수가 있는가?
- 벨만-포드 알고리즘(음수 사이클의 여부 판단 해준다)
- 음수간선(O) + 사이클(X) -> 최단 경로 나온다.
- 음수간선(O) + 사이클(O) -> 음수 사이클이 있다고 판별해준다. 최단 경로는 구할 수 없다.

1.2) 간선의 가중치에 음수가 없다.
- 간선의 가중치가 모두 동일한가? ( ex. 1)
  - BFS를 이용한다.
  - 단순한 BFS 이용한다.
  - 단순한 BFS로 부족하면 즉, 탐색의 깊이가 너무 깊거나 메모리의 양이 부족할 때 양방향 BFS를 이용한다.
  - 만약 양방향BFS에서 역방향으로 움직이기가 어렵다면 점점 깊어지는 탐색을 사용한다.
- 간선의 가중치가 다르다.
  - 다익스트라 알고리즘을 이용한다.

**N -> N**
- 시간 복잡도 O(|V^3|)
- 공간 복잡도 O(|V^2|)에도 괜찮으면 사용한다.
- 정점 1000개 내외
- 만약 음수 간선이 존재한다면 사이클을 확인해야한다.
- 플로이드 알고리즘을 한번 수행한 다음에 i->i 로 가는 정점이 0이아닌 음수가 나온다면
- 음수 사이클이 존재하므로 최단경로는 구할 수 없다.


