### Basic Code

1. Heapify : up, down 방식 모두 암기 / 삭제 / 삭제
2. Quick Sort 
3. Queue 
4. 순열, 조합 경우의 수를 만들어 내기
5. 부분 집합을 만들어 내기
6. Binaray Search 

### Basic Approach

0. 글과 그림으로 표현한다. 특히 조건문 / 순회 방식
1. DFS / BFS 로 풀어 낼 수 있는지 확인힌다.
   - 이때, 순회를 어떻게 할 것인가를 결정 ( 순열이나, 조합이냐, 부분 집합 이냐 ), 조건은 어떻게 어디서 판단할 것인가.
   - DFS : 한쪽으로 뻣어나가면서 검색하면서, 전체를 순회하고 답의 크기를 비교.
   - BFS : 둥굴게 둥굴게 퍼지면서 검색 - 최단거리를 찾을 때 사용, 처음나온 것이 답이다.
   
2. 메모이제이션
3. 절대 답이될수 없는 부분은 가지치기로 더이상 순회하지 않는다.
4. 2차원 상의 그래프에서 객체의 움직임 표현하고 기술 하는 방식을 구현
   - 특히 여러 객체가 동시에 움직이면 '동시'에 움직이는 것에 대해서 실수하지 않도록.
5. DP 로 풀수있는가? 
   - 사실상 아는 문제가 아니면 공식을 생각하기가 어렵다.

* 문제의 출력조건을 확인하라. 단순히 거리의 합인가? 목록을 출력하기 인가? 어떠한 제약조건이 있는가?
* 입력되는 노드가 크기가 백만이 넘어간다면 DP 또는 이분탐색을 고려해봐라.
* list 나 vector 를 사용하지 않고, 단순 배열 로 처리하기 위한 방법을 고려하라.
    - insert : szie++ 마지막 에 원소 삽입
    - delete : MAX 크기의 배열을 잡고, 마지막 원소를 삭제하려는 원소에 복사하고, size-- 를 수행.

### 유명한 알고리즘

0. 크루수컬 알고리즘 : 전체 노드를 최단 거리로 순회하기
   - Union Find 암기
1. 플로이드 와샬 : 전체 노드의 최단 거리 찾기.
   - O(n^3)
2. 다익스트라 : 시작점에서 마지막점이 주어진 경우 최단거리 찾기 
   - 정점과 간선의 개수가 늘아나면, 우선순위 Queue 를 구현해야하는데, STL 없이는 어려움.
   - [문제](https://www.acmicpc.net/problem/1753)
3. 라인 스위핑
   - 기본 개념에 비해서 실제 응용은 구현이 다양함.
   - 1차원 연결 -> 2차원으로 넘어가면 까다로움 -> 3차원은. 생각도 못하겠음.
  
### 문자열 관련 
